########################
## Basic parameters

## Sample information file with five columns: id / name / group / fq1 / fq2
src_sampleInfo	= "./sample.tsv"

## Genome folder depending on platform: CCHMC:HPC vs my desktop
import socket
hostname = socket.gethostname()	
if( hostname == "EA19-00359" ):
	# my desktop
	genomeFa	= "/Users/limc8h/Research/Common_Data/hg38/genome/genome.fa"
	chrom_size	= "/Users/limc8h/Research/Common_Data/hg38/chrom.sizes"
	peak_mask	= "/Users/limc8h/Research/Common_Data/hg38/ENCODE-blacklist.bed"
	baseDir		= "/Volumes"
else:
	# cluster system
	genomeFa	= "/data/limlab/Resource/GenomeData/hg/hg38/Genome/genome.fa"
	chrom_size	= "/data/limlab/Resource/GenomeData/hg/hg38/Genome/chrom.size"
	peak_mask	= "/data/limlab/Resource/GenomeData/hg/hg38/hg38-blacklist.v2.bed"
	baseDir		= "/data"

## Other essential pameters
genome			= "hg38"
adapter			= "AGATCGGAAGAGC"	# illumina universal adapter
#adapter			= "CTGTCTCTTATA"	# Nextera adapter for ATAC-seq or Cut&Tag
#trim_maxLen=100	## Maximum read length after trimming. ** NOT YET IMPLEMENTED **
trim_minLen		= 20
trim_minQual	= 20
chrRegexAll		= "^chr[0-9XY]+$|^dm-chr[0-9XYLR]+$"
chrRegexTarget	= "^chr[0-9XY]+$"
spikePrefix		= "dm-"

########################
## STAR index & options
star_index	= "/data/limlab/Resource/STAR_Index/hg38_allChr_v29_plusDm6"

## ChIP-seq / ATAC-seq / Cut&Run
star_option	= "--alignSJDBoverhangMin 999 --alignIntronMax 1 --alignMatesGapMax 2000 --outFilterMultimapNmax 1 --outFilterMismatchNoverLmax 0.05 --outReadsUnmapped None"
## Note:
## Additoinal star_option to prevent soft-clipping: "--alignEndsType EndToEnd"
## BAM sort by "--outSAMtype" is handled by the star.align.sh by -s option.
## To keep unmapped reads in the output bam file, add "--outSAMunmapped Within"

#########################
## Job flags
doTrim		= False
doDedup		= True

#########################
## Directories
fastqDir	= baseDir + "/iwafuchilab/NGS_Data_NextSeq/Seq006_011320_NB501763_0325_AHVLYNBGXC_CnR.ChIP/fastq_files"
trimDir		= "0.Fastq.Trim"
alignDir	= "1.1.Align"
filteredDir	= "1.2.Align.filtered"
dedupDir	= "1.3.Align.dedup"
splitDir	= "1.4.Align.split"
fragDir		= "1.4.Align.allFrag"
baseFreqDir = filteredDir + "/BaseFreq"
fragLenDir 	= dedupDir + "/fragLenHist"
homerDir	= "3.Homer"

spikeinCntDir = fragDir + "/spikeinCnt"

bigWigDir	= "2.1.BigWig"
bigWigDir_sub	= "2.2.BigWig.subInput"
bigWigDir_div	= "2.3.BigWig.divInput"
bigWigScaledDir	= "3.1.BigWig.scaled"
bigWigScaledDir_sub	= "3.2.BigWig.scaled.subInput"
bigWigScaledDir_div = "3.3.BigWig.scaled.divInput"

bigWigDir_sub_avg	= bigWigDir_sub + "/Avg"
bigWigScaledDir_sub_avg	= bigWigScaledDir_sub + "/Avg"
bigWigScaledDir_div_avg	= bigWigScaledDir_div + "/Avg"

## Hetero-chromatin domain calling
peakDir 	= "PeakCall"
peakWindow 	= 2000
peakStep	= 1000
peakFC		= 2
peakAlpha	= 1
peakSuffix	= "w%d.s%d.fc%.1f" % ( peakWindow, peakStep, peakFC )

peakDir2 	= "PeakCall.Homer"
peakSuffix2	= "w%d.fc%.1f" % ( peakWindow, peakFC )

## CODE used in the initial version
#def getfq(wildcards):
#	return "0.Fastq/" + samples_indexById.loc[wildcards.sampleId, ["Fq1","Fq2"]]
#
#def getfq_trim(wildcards):
#	sampleId = samples_indexByName.loc[wildcards.sampleName, ["Id"]]
#	return [ "0.Fastq/Trim/" + sampleId + "_1.trim.fq.gz", "0.Fastq/Trim/" + sampleId + "_2.trim.fq.gz" ]

################################
## Loading sample Information
import pandas as pd
import sys
samples = pd.read_csv(src_sampleInfo, sep="\t", comment="#", na_filter=False)
if not samples.Id.is_unique:
	print( "Error: Id column in sample.tsv is not unique")
	sys.exit()
if not samples.Name.is_unique:
	print( "Error: Name column in sample.tsv is not unique")
	sys.exit()

#################################
## Cluster configuration file
#cluster = json.load(open("./cluster.json"))
import yaml
with open('cluster.yml', 'r') as fh:
	cluster = yaml.load(fh)
#    cluster = yaml.full_load(fh)





#########################
## Rules start
#def getGroupToPool():
#	# groups that has more than one replicates
#	groupWithRep = set(samples.Group.value_counts().index[ samples.Group.value_counts() > 1 ])
#	# groups that is not input/control
#	groupNoneCtrl = set(samples.Group[samples.Ctrl != "NULL"])
#	groups = list( groupWithRep & groupNoneCtrl )
#	return groups

rule all:
	input:
		## output from check_baseFreq
		expand(filteredDir + "/BaseFreq/{sampleName}.filtered.R{read}.freq.line.png", sampleName=samples.Name.tolist(), read=[1,2]),
		## output from make_bigwig
		expand(bigWigDir + "/{sampleName}.bw", sampleName=samples.Name.tolist()),
		expand(bigWigDir_sub + "/{sampleName}.subInput.bw", sampleName=samples.Name[samples.Ctrl != "NULL"].tolist()),
#		expand(bigWigDir_div + "/{sampleName}.divInput.bw", sampleName=samples.Name[samples.Ctrl != "NULL"].tolist()),
		expand(bigWigScaledDir + "/{sampleName}.bw", sampleName=samples.Name.tolist()),
		expand(bigWigScaledDir_sub + "/{sampleName}.scaled.subInput.bw", sampleName=samples.Name[samples.Ctrl != "NULL"].tolist()),
#		expand(bigWigScaledDir_div + "/{sampleName}.scaled.divInput.bw", sampleName=samples.Name[samples.Ctrl != "NULL"].tolist()),
#		expand(bigWigDir_sub_avg + "/{groupName}.subInput.avg.bw",
#			groupName= list( set(samples.Group.value_counts().index[ samples.Group.value_counts() > 1 ]) & set(samples.Group[samples.Ctrl != "NULL"]) ) ),
#		expand(bigWigScaledDir_sub_avg + "/{groupName}.scaled.subInput.avg.bw", 
#			groupName= list( set(samples.Group.value_counts().index[ samples.Group.value_counts() > 1 ]) & set(samples.Group[samples.Ctrl != "NULL"]) ) ),
#		expand(bigWigScaledDir_div_avg + "/{groupName}.scaled.divInput.avg.bw", 
#			groupName= list( set(samples.Group.value_counts().index[ samples.Group.value_counts() > 1 ]) & set(samples.Group[samples.Ctrl != "NULL"]) ) ),
		#expand(homerDir + "/{sampleName}/HomerPeak/peak.homer.exBL.1rpm.bed", sampleName=samples.Name.tolist()),
		## fragment bed file
		#expand(fragDir + "/{sampleName}.frag.bed.gz", sampleName=samples.Name.tolist())
		## fragment length distribution
		expand(fragLenDir + "/{sampleName}.dist.png", sampleName=samples.Name.tolist()),
#		expand(spikeinCntDir + "/{sampleName}.spikeCnt.txt", sampleName=samples.Name.tolist())
		spikeinCntDir + "/spikein.txt",
		expand(peakDir + "/{sampleName}.{suffix}.{ext}", sampleName=samples.Name[samples.Ctrl != "NULL"].tolist(), suffix=peakSuffix, ext=["bed","txt.gz"]),
		expand(peakDir2 + "/{sampleName}.{suffix}.exBL.bed", sampleName=samples.Name[samples.Ctrl != "NULL"].tolist(), suffix=peakSuffix2)
		## homer tag dir
		#expand(homerDir + "/{sampleName}/TSV", sampleName=samples.Name.tolist())

		## output from trim
#		expand(trimDir + "/{sampleId}_1.trim.fq.gz", sampleId=samples["Id"].tolist()),
#		expand(trimDir + "/{sampleId}_2.trim.fq.gz", sampleId=samples["Id"].tolist())
#		expand("1.4.Align.split/{sampleId}.filtered.dedup.{group}.{proctype}.bed.gz", 
#			sampleId=samples["Id"].tolist(),
#			group=["nfr","nuc"],
#			proctype=["con","ctr","sep"])
#		expand("1.3.Align.dedup/{sampleId}.filtered.dedup.bam", sampleId=samples["Id"].tolist()),
#		expand("1.2.Align.filtered/{sampleId}.filtered.bam", sampleId=samples.index.values.tolist()),

#rule clean:
#	shell:
#		"rm -rf " + " ".join([ trimDir, alignDir, filteredDir, dedupDir, splitDir, baseFreqDir, bigWigDir ])

include: os.environ["MY_SCRIPT_BASE"] + "/Pipeline/Snakemake/rules.pre.smk"
include: os.environ["MY_SCRIPT_BASE"] + "/Pipeline/Snakemake/rules.post.smk"
